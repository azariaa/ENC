package main.java.inmind.emailqaagent;

import main.java.inmind.Calendar.EventDetector;
import main.java.inmind.Calendar.GCalendar;
import main.java.inmind.email.EmailInstance;
import main.java.inmind.email.EmailOperations;
import main.java.inmind.qa.piazza.PiazzaQA;

import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Logger;

/**
 * Created by Amos Azaria on 01-Dec-15.
 */
public class EmailActor
{
    private static final String disclaimer = "Disclaimer: This email was generated by the InMind Email Agent.";
    private static final Format formatter = new SimpleDateFormat("MM/dd h:mm a");
    private static final int meetingDuration = 30; //in minutes

    Logger LOG;
    private GCalendar gCalendar = new GCalendar();
    private EmailOperations emailOperations;
    String pythonScriptPath;
    String username;
    String password;
    String indexLocation;
    String course_id;

    Map<String,EventDetector.EventInfo> userProposedDate = new HashMap<>();

    public EmailActor(String username, String password, Logger LOG, String pythonScriptPath, String indexLocation, String course_id)
    {
        this.username = username;
        this.password = password;
        this.LOG = LOG;
        this.pythonScriptPath = pythonScriptPath;
        this.indexLocation = indexLocation;
        this.course_id = course_id;
        emailOperations = new EmailOperations(username, password, username);

    }

    public void checkEmailsAndAct()
    {

        //String tempEmailFileName = prop.getProperty("temp_email_file");
        Date lastFetch = PiazzaQA.loadLastFetchDate(pythonScriptPath);
        Optional<Date> fetchDate = Optional.empty();//new Date(new Date().getTime() - 10*60*1000); //10 minutes ago
        List<EmailInstance> recentEmails = emailOperations.extractLastEmails(lastFetch, 50);

        boolean invokedPiazzaQA = false;
        for (EmailInstance email : recentEmails)
        {
            LOG.info("new email: " + email);
            if (!fetchDate.isPresent() || email.receiveDate.getTime() > fetchDate.get().getTime())
                fetchDate = Optional.of(email.receiveDate); //the latest fetch
            //System.out.println(email);
            if (email.senderList.stream().anyMatch(x -> x.contains("no-reply@piazza.com"))) //email.getAllSenders().contains(...)
            {
                if (!invokedPiazzaQA)
                {
                    LOG.info("Found Piazza Email!");
                    PiazzaQA.invoke(username, password, pythonScriptPath, indexLocation, course_id, LOG);
                    invokedPiazzaQA = true;
                }
            }
            else
            {
                actOnMeetingEmail(email);
            }
        }

        if (fetchDate.isPresent())
        {
            PiazzaQA.updateLastFetchDate(fetchDate.get(), pythonScriptPath);
        }
    }

    private void actOnMeetingEmail(EmailInstance email)
    {
        EventDetector.EventInfo eventInfo = EventDetector.emailEventInfo(email);
        LOG.info("email info: type:" + eventInfo.eventType);
        if (eventInfo.eventType == EventDetector.EventType.meetingRequest)
        {
            if (gCalendar.amIFree(eventInfo.when, meetingDuration))
            {
                createEvent(eventInfo);
            }
            else
            {
                Optional<Date> nextAvailable = gCalendar.nextFreeTime(eventInfo.when, meetingDuration);
                //send email to eventInfo.who with proposed slot
                String emailBody = "Hello,\n\nUnfortunately, I'm not available at " + formatter.format(eventInfo.when) + ". ";
                if (nextAvailable.isPresent())
                {
                    emailBody += "\nMy next available slot is at " + formatter.format(nextAvailable.get()) + ". ";
                    emailBody += "Will that work for you?";
                    EventDetector.EventInfo proposedEventInfo = eventInfo.cloneWithNewTime(nextAvailable.get());
                    userProposedDate.put(email.getAllSenders(), proposedEventInfo);
                }
                emailBody += "\n\n" + disclaimer;
                emailOperations.sendEmail("Meeting Scheduling", emailBody, eventInfo.who);
            }

            LOG.info("email info: what:" + eventInfo.what);
            LOG.info("email info: who:" + eventInfo.who);
            LOG.info("email info: when:" + eventInfo.when.toString());
        }
        else if (eventInfo.eventType == EventDetector.EventType.eventAccept)
        {
            if (userProposedDate.containsKey(email.getAllSenders()))
            {
                createEvent(userProposedDate.get(email.getAllSenders()));
            }
        }
    }

    private void createEvent(EventDetector.EventInfo eventInfo)
    {
        //add to calendar
        gCalendar.createAnEvent(eventInfo, meetingDuration);
        //send email to eventInfo.who
        emailOperations.sendEmail("Meeting Confirmed",
                "Hello,\n\nYour requested meeting for " + formatter.format(eventInfo.when) + " was confirmed. \n\n" + disclaimer,
                eventInfo.who);
    }
}
